#!/bin/bash
# cc-logs - View and filter Claude Code Remote Control server logs
#
# Usage:
#   cc-logs              # Tail the log file
#   cc-logs -f           # Follow (like tail -f)
#   cc-logs -e           # Show errors only
#   cc-logs -s work      # Filter by session name
#   cc-logs -n 50        # Show last 50 lines
#   cc-logs --prompts    # Show only prompt detections
#   cc-logs --notify     # Show only notification events

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="$SCRIPT_DIR/server.log"

# Colors (using $'...' for proper escape interpretation)
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
CYAN=$'\033[0;36m'
BOLD=$'\033[1m'
NC=$'\033[0m'

# Defaults
FOLLOW=false
ERRORS_ONLY=false
SESSION=""
LINES=100
FILTER=""
PROMPTS_ONLY=false
NOTIFY_ONLY=false
NO_COLOR=false

show_help() {
    echo "Usage: cc-logs [OPTIONS]"
    echo ""
    echo "View and filter server logs."
    echo ""
    echo "Options:"
    echo "  -f, --follow       Follow log output (like tail -f)"
    echo "  -e, --errors       Show errors and warnings only"
    echo "  -s, --session NAME Filter by session name"
    echo "  -n, --lines N      Number of lines to show (default: 100)"
    echo "  -g, --grep PATTERN Grep for pattern"
    echo "  --prompts          Show only prompt detection events"
    echo "  --notify           Show only notification events"
    echo "  --no-color         Disable color output"
    echo "  -h, --help         Show this help"
    echo ""
    echo "Examples:"
    echo "  cc-logs -f                  # Follow logs in real-time"
    echo "  cc-logs -e                  # Show errors only"
    echo "  cc-logs -s work -n 50       # Last 50 lines for 'work' session"
    echo "  cc-logs --prompts           # Show prompt detections"
    echo "  cc-logs -g 'ntfy'           # Grep for ntfy-related logs"
    exit 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--follow)
            FOLLOW=true
            shift
            ;;
        -e|--errors)
            ERRORS_ONLY=true
            shift
            ;;
        -s|--session)
            SESSION="$2"
            shift 2
            ;;
        -n|--lines)
            LINES="$2"
            shift 2
            ;;
        -g|--grep)
            FILTER="$2"
            shift 2
            ;;
        --prompts)
            PROMPTS_ONLY=true
            shift
            ;;
        --notify)
            NOTIFY_ONLY=true
            shift
            ;;
        --no-color)
            NO_COLOR=true
            shift
            ;;
        -h|--help)
            show_help
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use -h or --help for usage"
            exit 1
            ;;
    esac
done

# Check if log file exists
if [ ! -f "$LOG_FILE" ]; then
    echo -e "${YELLOW}Log file not found:${NC} $LOG_FILE"
    echo "The server may not have been started yet, or file logging is disabled."
    echo ""
    echo "Check config.yaml:"
    echo "  logging:"
    echo "    file_enabled: true"
    exit 1
fi

# Build the filter pipeline
build_filter() {
    local filter_cmd="cat"

    # Session filter
    if [ -n "$SESSION" ]; then
        filter_cmd="$filter_cmd | grep -E '\\[$SESSION\\]'"
    fi

    # Errors only
    if [ "$ERRORS_ONLY" = true ]; then
        filter_cmd="$filter_cmd | grep -iE '(ERROR|WARNING|WARN|error|warning|failed|exception)'"
    fi

    # Prompts only
    if [ "$PROMPTS_ONLY" = true ]; then
        filter_cmd="$filter_cmd | grep -iE '(prompt detected|NEW prompt|idle prompt|question prompt)'"
    fi

    # Notify only
    if [ "$NOTIFY_ONLY" = true ]; then
        filter_cmd="$filter_cmd | grep -iE '(ntfy|pushover|notification|Sending notification)'"
    fi

    # Custom grep
    if [ -n "$FILTER" ]; then
        filter_cmd="$filter_cmd | grep -iE '$FILTER'"
    fi

    echo "$filter_cmd"
}

# Colorize output
colorize() {
    if [ "$NO_COLOR" = true ]; then
        cat
    else
        sed \
            -e "s/\[ERROR\]/${RED}[ERROR]${NC}/g" \
            -e "s/\[WARNING\]/${YELLOW}[WARNING]${NC}/g" \
            -e "s/\[INFO\]/${GREEN}[INFO]${NC}/g" \
            -e "s/\[DEBUG\]/${CYAN}[DEBUG]${NC}/g" \
            -e "s/NEW prompt detected!/${BOLD}${GREEN}NEW prompt detected!${NC}/g" \
            -e "s/Sending notification/${BOLD}${BLUE}Sending notification${NC}/g" \
            -e "s/\[ntfy\]/${CYAN}[ntfy]${NC}/g" \
            -e "s/\[pushover\]/${CYAN}[pushover]${NC}/g"
    fi
}

# Show log info
log_size=$(du -h "$LOG_FILE" 2>/dev/null | cut -f1)
log_lines=$(wc -l < "$LOG_FILE" | tr -d ' ')
echo -e "${BOLD}Log file:${NC} $LOG_FILE ($log_size, $log_lines lines)"
echo -e "${BOLD}Showing:${NC} last $LINES lines"

[ -n "$SESSION" ] && echo -e "${BOLD}Session:${NC} $SESSION"
[ "$ERRORS_ONLY" = true ] && echo -e "${BOLD}Filter:${NC} errors/warnings only"
[ "$PROMPTS_ONLY" = true ] && echo -e "${BOLD}Filter:${NC} prompt detections only"
[ "$NOTIFY_ONLY" = true ] && echo -e "${BOLD}Filter:${NC} notification events only"
[ -n "$FILTER" ] && echo -e "${BOLD}Grep:${NC} $FILTER"
[ "$FOLLOW" = true ] && echo -e "${BOLD}Mode:${NC} following (Ctrl+C to stop)"

echo ""
echo -e "${BLUE}────────────────────────────────────────────────${NC}"

FILTER_CMD=$(build_filter)

if [ "$FOLLOW" = true ]; then
    # Follow mode
    tail -n "$LINES" -f "$LOG_FILE" | eval "$FILTER_CMD" | colorize
else
    # Static mode
    tail -n "$LINES" "$LOG_FILE" | eval "$FILTER_CMD" | colorize
fi
